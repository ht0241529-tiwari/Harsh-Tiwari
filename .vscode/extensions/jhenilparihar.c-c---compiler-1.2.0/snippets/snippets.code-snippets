{
  "multipopStack.c": {
    "prefix": "$multipopStack",
    "body": [
      "#include <stdio.h>",
      "#define STACK_SIZE 10",
      "",
      "int stack[STACK_SIZE];",
      "int top = -1;",
      "",
      "void push(int value) {",
      "\ttop++;",
      "\tif (top >= STACK_SIZE) {",
      "\t\tprintf(\"Error : max stack size reached\");",
      "\t\treturn;",
      "\t} else {",
      "\t\tstack[top] = value;",
      "\t}",
      "}",
      "",
      "void pop() {",
      "\tif (top == -1) {",
      "\t\tprintf(\"Error : stack has no elements to pop\");",
      "\t} else {",
      "\t\ttop--;",
      "\t}",
      "}",
      "",
      "void multipop(int n) {",
      "\tprintf(\"Popping %d elements\\n\", n);",
      "\tif (top == -1) {",
      "\t\tprintf(\"Error : stack has no elements to pop\");",
      "\t} else if (n > top + 1) {",
      "\t\tprintf(\"Error : stack has less than %d elements\", n);",
      "\t} else {",
      "\t\ttop -= n;",
      "\t}",
      "}",
      "",
      "void printStack() {",
      "\tprintf(\"Stack : \");",
      "\tfor (int i = 0; i <= top; i++) {",
      "\t\tprintf(\"%d \", stack[i]);",
      "\t}",
      "\tprintf(\"\\n\");",
      "}",
      "",
      "int main() {",
      "\tprintf(\"Pushing 1, 2, 3, 4, 5\\n\");",
      "\tpush(1);",
      "\tpush(2);",
      "\tpush(3);",
      "\tpush(4);",
      "\tpush(5);",
      "\tprintStack();",
      "\tmultipop(3);",
      "\tprintStack();",
      "\tprintf(\"Pushing 6, 7\\n\");",
      "\tpush(6);",
      "\tpush(7);",
      "\tprintStack();",
      "\tmultipop(2);",
      "\tprintStack();",
      "\treturn 0;",
      "}"
    ],
    "description": "Multiple Pop Operations in Stack"
  },
  "dynamicArray.c": {
    "prefix": "$dynamicArray",
    "body": [
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "",
      "int ArraySize = 0;",
      "int top = -1;",
      "int array[100];",
      "",
      "void initArray() {",
      "\tfor (int i = 0; i < 100; i++) {",
      "\t\tarray[i] = -1;",
      "\t}",
      "}",
      "",
      "void printArray() {",
      "\tprintf(\"Array: \\n\");",
      "\tfor (int i = 0; i < ArraySize; i++) {",
      "\t\tif (array[i] != -1)",
      "\t\t\tprintf(\"%d \", array[i]);",
      "\t\telse",
      "\t\t\tprintf(\"_ \");",
      "\t}",
      "\tprintf(\"\\n\");",
      "}",
      "",
      "bool isArrayFull() {",
      "\tfor (int i = 0; i < ArraySize; i++) {",
      "\t\tif (array[i] == -1)",
      "\t\t\treturn false;",
      "\t}",
      "\treturn true;",
      "}",
      "",
      "void push(int value) {",
      "\ttop++;",
      "\tif (ArraySize == 0) {",
      "\t\tArraySize = 1;",
      "\t} else {",
      "\t\tbool x = isArrayFull();",
      "\t\tif (x == true) {",
      "\t\t\tArraySize = ArraySize * 2;",
      "\t\t}",
      "\t}",
      "\tarray[top] = value;",
      "\tprintArray();",
      "}",
      "",
      "void del(int value) {",
      "\tint index = -1;",
      "\tif (top == -1) {",
      "\t\tprintf(\"Error : array is empty\");",
      "\t\treturn;",
      "\t}",
      "\tfor (int i = 0; i < top; i++) {",
      "\t\tif (array[i] == value)",
      "\t\t\tindex = i;",
      "\t}",
      "\tif (index == -1) {",
      "\t\tprintf(\"Error : element not found\");",
      "\t\treturn;",
      "\t} else {",
      "\t\tif (index == top) {",
      "\t\t\tarray[index] = -1;",
      "\t\t\ttop--;",
      "\t\t} else {",
      "\t\t\twhile (index == top - 1) {",
      "\t\t\t\tint temp = array[index];",
      "\t\t\t\tarray[index] = array[index + 1];",
      "\t\t\t\tarray[index + 1] = temp;",
      "\t\t\t\tindex++;",
      "\t\t\t}",
      "\t\t\tarray[top] = -1;",
      "\t\t\ttop--;",
      "\t\t}",
      "\t\tif ((ArraySize - top - 1) == (top + 1)) {",
      "\t\t\tArraySize = ArraySize / 2;",
      "\t\t}",
      "\t\tprintArray();",
      "\t}",
      "}",
      "",
      "int main() {",
      "\tinitArray();",
      "\tpush(1);",
      "\tpush(2);",
      "\tpush(3);",
      "\tpush(4);",
      "\tpush(5);",
      "\tdel(4);",
      "\tpush(3);",
      "\tpush(4);",
      "\tpush(5);",
      "\tpush(6);",
      "\tpush(8);",
      "\treturn 0;",
      "}"
    ],
    "description": "Dynamic Array Operations"
  },
  "binaryCounter.c": {
    "prefix": "$binaryCounter",
    "body": [
      "#include <stdio.h>",
      "",
      "int array[10];",
      "int count = 0;",
      "",
      "void initArray() {",
      "\tfor (int i = 0; i < 10; i++) {",
      "\t\tarray[i] = 0;",
      "\t}",
      "}",
      "",
      "void printArray() {",
      "\tprintf(\"%d\\t : \\t\", count);",
      "\tfor (int i = 0; i < 10; i++)",
      "\t\tprintf(\"%d \", array[i]);",
      "\tprintf(\"\\n\");",
      "}",
      "",
      "void push() {",
      "\tprintf(\"\\nPush\\n\");",
      "\t++count;",
      "\tint index = 9;",
      "\tif (array[index] == 0) {",
      "\t\tarray[index] = 1;",
      "\t} else {",
      "\t\twhile (array[index] != 0) {",
      "\t\t\tarray[index] = 0;",
      "\t\t\tindex--;",
      "\t\t}",
      "\t\tarray[index] = 1;",
      "\t}",
      "\tprintArray();",
      "}",
      "",
      "void pop() {",
      "\tprintf(\"\\nPop\\n\");",
      "\t--count;",
      "\tint index = -1;",
      "\tfor (int i = 9; i >= 0; i--) {",
      "\t\tif (array[i] == 1) {",
      "\t\t\tindex = i;",
      "\t\t\tbreak;",
      "\t\t}",
      "\t}",
      "\tif (index == 9) {",
      "\t\tarray[index] = 0;",
      "\t} else {",
      "\t\tarray[index] = 0;",
      "\t\tfor (int i = (index + 1); i <= 9; i++) {",
      "\t\t\tarray[i] = 1;",
      "\t\t}",
      "\t}",
      "\tprintArray();",
      "}",
      "",
      "int main() {",
      "\tinitArray();",
      "\tprintArray();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpush();",
      "\tpop();",
      "\tpop();",
      "\tpush();",
      "\treturn 0;",
      "}"
    ],
    "description": "Binary Counter Operations"
  },
  "trie.c": {
    "prefix": "$tries",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#define ALPHABET_SIZE 26",
      "// Trie node structure",
      "struct TrieNode",
      "{",
      "struct TrieNode *children[ALPHABET_SIZE];",
      "int isEndOfWord;",
      "};",
      "// Function to initialize a new trie node",
      "struct TrieNode *createNode()",
      "{",
      "struct TrieNode *node = (struct TrieNode *)malloc(sizeof(struct TrieNode));",
      "for (int i = 0; i < ALPHABET_SIZE; i++)",
      "{",
      "node->children[i] = NULL;",
      "}",
      "node->isEndOfWord = 0;",
      "return node;",
      "}",
      "// Function to check if a node has no children",
      "int isNodeEmpty(struct TrieNode *node)",
      "{",
      "for (int i = 0; i < ALPHABET_SIZE; i++)",
      "{",
      "if (node->children[i] != NULL)",
      "{",
      "return 0;",
      "}",
      "}",
      "return 1;",
      "}",
      "",
      "// Function to insert a word into the trie",
      "void insert(struct TrieNode *root, const char *word)",
      "{",
      "struct TrieNode *currentNode = root;",
      "for (int i = 0; i < strlen(word); i++)",
      "{",
      "int index = word[i] - 'a';",
      "if (currentNode->children[index] == NULL)",
      "{",
      "currentNode->children[index] = createNode();",
      "}",
      "currentNode = currentNode->children[index];",
      "}",
      "currentNode->isEndOfWord = 1;",
      "}",
      "",
      "// Function to search for a word in the trie",
      "int search(struct TrieNode *root, const char *word)",
      "{",
      "struct TrieNode *currentNode = root;",
      "for (int i = 0; i < strlen(word); i++)",
      "{",
      "int index = word[i] - 'a';",
      "if (currentNode->children[index] == NULL)",
      "{",
      "return 0; // Word not found",
      "}",
      "currentNode = currentNode->children[index];",
      "}",
      "return (currentNode != NULL && currentNode->isEndOfWord);",
      "}",
      "",
      "// Function to delete a word from the trie",
      "int deleteWord(struct TrieNode *root, const char *word, int depth)",
      "{",
      "if (root == NULL)",
      "{",
      "return 0;",
      "}",
      "// Base case: If the last character of the word is reached",
      "if (depth == strlen(word))",
      "{",
      "if (root->isEndOfWord)",
      "{",
      "root->isEndOfWord = 0;",
      "",
      "// Check if the node has no children, then it can be deleted",
      "int isEmpty = 1;",
      "for (int i = 0; i < ALPHABET_SIZE; i++)",
      "{",
      "if (root->children[i] != NULL)",
      "{",
      "isEmpty = 0;",
      "break;",
      "}",
      "}",
      "",
      "return isEmpty;",
      "}",
      "}",
      "else",
      "{",
      "int index = word[depth] - 'a';",
      "if (deleteWord(root->children[index], word, depth + 1))",
      "{",
      "free(root->children[index]);",
      "root->children[index] = NULL;",
      "",
      "// Check if the current node is not the end of another word and has no other children",
      "return !(root->isEndOfWord) && isNodeEmpty(root);",
      "}",
      "}",
      "",
      "return 0;",
      "}",
      "// Function to free the memory allocated for the trie",
      "void freeTrie(struct TrieNode *root)",
      "{",
      "if (root == NULL)",
      "{",
      "return;",
      "}",
      "for (int i = 0; i < ALPHABET_SIZE; i++)",
      "{",
      "freeTrie(root->children[i]);",
      "}",
      "free(root);",
      "}",
      "",
      "// Function to display the menu",
      "void displayMenu()",
      "{",
      "printf(\"\\nMenu:\\n\");",
      "printf(\"1. Insert a word\\n\");",
      "printf(\"2. Search for a word\\n\");",
      "printf(\"3. Delete a word\\n\");",
      "printf(\"4. Exit\\n\");",
      "}",
      "",
      "int main()",
      "{",
      "struct TrieNode *root = createNode();",
      "int choice;",
      "char word[50];",
      "",
      "do",
      "{",
      "displayMenu();",
      "printf(\"Enter your choice: \");",
      "scanf(\"%d\", &choice);",
      "",
      "switch (choice)",
      "{",
      "case 1:",
      "printf(\"Enter the word to insert: \");",
      "scanf(\"%s\", word);",
      "insert(root, word);",
      "printf(\"Word '%s' inserted into the trie.\\n\", word);",
      "break;",
      "case 2:",
      "printf(\"Enter the word to search: \");",
      "scanf(\"%s\", word);",
      "if (search(root, word))",
      "{",
      "printf(\"Word '%s' found in the trie.\\n\", word);",
      "}",
      "else",
      "{",
      "printf(\"Word '%s' not found in the trie.\\n\", word);",
      "}",
      "break;",
      "case 3:",
      "printf(\"Enter the word to delete: \");",
      "scanf(\"%s\", word);",
      "if (deleteWord(root, word, 0))",
      "{",
      "printf(\"Word '%s' deleted from the trie.\\n\", word);",
      "}",
      "else",
      "{",
      "printf(\"Word '%s' not found in the trie.\\n\", word);",
      "}",
      "break;",
      "case 4:",
      "printf(\"Exiting the program.\\n\");",
      "break;",
      "default:",
      "printf(\"Invalid choice. Please enter a valid option.\\n\");",
      "}",
      "} while (choice != 4);",
      "// Free the allocated memory",
      "freeTrie(root);",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "binomialHeap.c": {
    "prefix": "$binomialHeap",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "// Structure to represent a node in a binomial heap",
      "struct Node",
      "{",
      "int key;              // Key of the node",
      "int degree;           // Degree of the node (order of the binomial tree)",
      "struct Node *parent;  // Pointer to the parent node",
      "struct Node *child;   // Pointer to the leftmost child node",
      "struct Node *sibling; // Pointer to the next sibling node",
      "};",
      "",
      "// Function to create a new node with a given key",
      "struct Node *createNode(int key)",
      "{",
      "// Allocate memory for a new node",
      "struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));",
      "// If memory allocation fails, return NULL",
      "if (newNode == NULL)",
      "{",
      "return NULL;",
      "}",
      "// Initialize the new node",
      "newNode->key = key;",
      "newNode->degree = 0;",
      "newNode->parent = NULL;",
      "newNode->child = NULL;",
      "newNode->sibling = NULL;",
      "return newNode;",
      "}",
      "",
      "// Function to merge two binomial trees of the same order",
      "struct Node *binomialHeapMerge(struct Node *h1, struct Node *h2)",
      "{",
      "// If one of the heaps is empty, return the other heap",
      "if (h1 == NULL)",
      "{",
      "return h2;",
      "}",
      "else if (h2 == NULL)",
      "{",
      "return h1;",
      "}",
      "",
      "// Initialize pointers for the merged heap",
      "struct Node *head = NULL;   // Head of the merged heap",
      "struct Node *tail = NULL;   // Tail of the merged heap",
      "struct Node *prev = NULL;   // Pointer to the previous node in the merged heap",
      "struct Node *current1 = h1; // Pointer to the current node in the first heap",
      "struct Node *current2 = h2; // Pointer to the current node in the second heap",
      "",
      "// Merge the heaps until one of them becomes empty",
      "while (current1 != NULL && current2 != NULL)",
      "{",
      "// Compare the degrees of the current nodes in both heaps",
      "if (current1->degree <= current2->degree)",
      "{",
      "// If the tail is NULL, this is the first node in the merged heap",
      "if (tail == NULL)",
      "{",
      "head = current1;",
      "}",
      "else",
      "{",
      "// Otherwise, append the current node from the first heap to the merged heap",
      "tail->sibling = current1;",
      "}",
      "// Move the tail pointer to the newly added node",
      "tail = current1;",
      "// Move to the next node in the first heap",
      "current1 = current1->sibling;",
      "}",
      "else",
      "{",
      "// If the tail is NULL, this is the first node in the merged heap",
      "if (tail == NULL)",
      "{",
      "head = current2;",
      "}",
      "else",
      "{",
      "// Otherwise, append the current node from the second heap to the merged heap",
      "tail->sibling = current2;",
      "}",
      "// Move the tail pointer to the newly added node",
      "tail = current2;",
      "// Move to the next node in the second heap",
      "current2 = current2->sibling;",
      "}",
      "// Ensure the tail's sibling pointer is NULL",
      "tail->sibling = NULL;",
      "}",
      "",
      "// If there are remaining nodes in the first heap, append them to the merged heap",
      "while (current1 != NULL)",
      "{",
      "tail->sibling = current1;",
      "tail = current1;",
      "current1 = current1->sibling;",
      "tail->sibling = NULL;",
      "}",
      "",
      "// If there are remaining nodes in the second heap, append them to the merged heap",
      "while (current2 != NULL)",
      "{",
      "tail->sibling = current2;",
      "tail = current2;",
      "current2 = current2->sibling;",
      "tail->sibling = NULL;",
      "}",
      "",
      "// Return the head of the merged heap",
      "return head;",
      "}",
      "",
      "int main()",
      "{",
      "// Create two heaps",
      "struct Node *heap1 = createNode(1);",
      "heap1->sibling = createNode(5);",
      "",
      "struct Node *heap2 = createNode(2);",
      "heap2->sibling = createNode(3);",
      "",
      "// Print the keys of the nodes in the first heap",
      "printf(\"Heap 1:\\n\");",
      "struct Node *current1 = heap1;",
      "while (current1 != NULL)",
      "{",
      "printf(\"%d \", current1->key);",
      "current1 = current1->sibling;",
      "}",
      "",
      "// Print the keys of the nodes in the second heap",
      "printf(\"\\nHeap 2:\\n\");",
      "struct Node *current2 = heap2;",
      "while (current2 != NULL)",
      "{",
      "printf(\"%d \", current2->key);",
      "current2 = current2->sibling;",
      "}",
      "",
      "// Merge the two heaps",
      "struct Node *mergedHeap = binomialHeapMerge(heap1, heap2);",
      "",
      "// Print the keys of the nodes in the merged heap",
      "printf(\"\\nMerged Heap:\\n\");",
      "struct Node *currentMerged = mergedHeap;",
      "while (currentMerged != NULL)",
      "{",
      "printf(\"%d \", currentMerged->key);",
      "currentMerged = currentMerged->sibling;",
      "}",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "fibonaciHeap.c": {
    "prefix": "$fibonaciHeap",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "// Node structure for Fibonacci Heap",
      "typedef struct Node {",
      "int key;",
      "struct Node* parent;",
      "struct Node* child;",
      "struct Node* left;",
      "struct Node* right;",
      "int degree;  // Degree of the node (number of children)",
      "int marked;  // Mark flag for cascading cuts",
      "} Node;",
      "",
      "// Function to create a new node with a given key",
      "Node* createNode(int key) {",
      "Node* newNode = (Node*)malloc(sizeof(Node));",
      "if (newNode != NULL) {",
      "newNode->key = key;",
      "newNode->parent = NULL;",
      "newNode->child = NULL;",
      "newNode->left = newNode;",
      "newNode->right = newNode;",
      "newNode->degree = 0;",
      "newNode->marked = 0;",
      "}",
      "return newNode;",
      "}",
      "",
      "// Function to link two Fibonacci Heap trees of the same degree",
      "void link(Node* root1, Node* root2) {",
      "root2->left->right = root2->right;",
      "root2->right->left = root2->left;",
      "",
      "root2->left = root2;",
      "root2->right = root2;",
      "",
      "root2->parent = root1;",
      "",
      "if (root1->child == NULL) {",
      "root1->child = root2;",
      "} else {",
      "root2->right = root1->child;",
      "root2->left = root1->child->left;",
      "root1->child->left->right = root2;",
      "root1->child->left = root2;",
      "}",
      "",
      "root1->degree++;",
      "}",
      "",
      "// Function to merge two Fibonacci Heaps",
      "Node* mergeFibonacciHeaps(Node* heap1, Node* heap2) {",
      "if (heap1 == NULL) {",
      "return heap2;",
      "}",
      "",
      "if (heap2 == NULL) {",
      "return heap1;",
      "}",
      "",
      "Node* temp = heap1->right;",
      "heap1->right = heap2->right;",
      "heap2->right->left = heap1;",
      "heap2->right = temp;",
      "temp->left = heap2;",
      "",
      "return heap1;",
      "}",
      "",
      "// Function to perform the merge operation on two Fibonacci Heaps",
      "Node* fibonacciHeapMerge(Node* heap1, Node* heap2) {",
      "Node* mergedHeap = mergeFibonacciHeaps(heap1, heap2);",
      "",
      "if (mergedHeap == NULL) {",
      "return NULL;",
      "}",
      "",
      "Node* minNode = mergedHeap;",
      "Node* current = mergedHeap->right;",
      "",
      "while (current != mergedHeap) {",
      "if (current->key < minNode->key) {",
      "minNode = current;",
      "}",
      "current = current->right;",
      "}",
      "",
      "return minNode;",
      "}",
      "",
      "// Function to print the elements of a Fibonacci Heap",
      "void printFibonacciHeap(Node* minNode) {",
      "if (minNode == NULL) {",
      "printf(\"Heap is empty.\\n\");",
      "return;",
      "}",
      "",
      "printf(\"Fibonacci Heap elements: \");",
      "Node* current = minNode;",
      "do {",
      "printf(\"%d \", current->key);",
      "current = current->right;",
      "} while (current != minNode);",
      "printf(\"\\n\");",
      "}",
      "",
      "int main() {",
      "int key;",
      "Node* heap1 = NULL;",
      "Node* heap2 = NULL;",
      "",
      "// Get user input for the keys of the first Fibonacci Heap",
      "printf(\"Enter keys for the first Fibonacci Heap (enter -1 to stop):\\n\");",
      "while (1) {",
      "scanf(\"%d\", &key);",
      "if (key == -1) {",
      "break;",
      "}",
      "Node* newNode = createNode(key);",
      "heap1 = mergeFibonacciHeaps(heap1, newNode);",
      "}",
      "",
      "// Get user input for the keys of the second Fibonacci Heap",
      "printf(\"Enter keys for the second Fibonacci Heap (enter -1 to stop):\\n\");",
      "while (1) {",
      "scanf(\"%d\", &key);",
      "if (key == -1) {",
      "break;",
      "}",
      "Node* newNode = createNode(key);",
      "heap2 = mergeFibonacciHeaps(heap2, newNode);",
      "}",
      "",
      "// Merge the two Fibonacci Heaps",
      "Node* mergedHeap = fibonacciHeapMerge(heap1, heap2);",
      "",
      "// Print the merged Fibonacci Heap",
      "printFibonacciHeap(mergedHeap);",
      "",
      "// Free allocated memory (you would need to implement a proper free function)",
      "free(heap1);",
      "free(heap2);",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "leftistHeap.c": {
    "prefix": "$leftistHeap",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "// Structure to represent a node in a Leftist Heap",
      "struct LeftistNode",
      "{",
      "int key;                   // Key of the node",
      "int rank;                  // Rank of the node",
      "struct LeftistNode *left;  // Pointer to the left child node",
      "struct LeftistNode *right; // Pointer to the right child node",
      "};",
      "",
      "// Function to create a new Leftist node",
      "struct LeftistNode *createLeftistNode(int key)",
      "{",
      "// Allocate memory for a new node",
      "struct LeftistNode *newNode = (struct LeftistNode *)malloc(sizeof(struct LeftistNode));",
      "// If memory allocation is successful, initialize the new node",
      "if (newNode != NULL)",
      "{",
      "newNode->key = key;",
      "newNode->rank = 0;",
      "newNode->left = NULL;",
      "newNode->right = NULL;",
      "}",
      "// Return the new node",
      "return newNode;",
      "}",
      "",
      "// Function to merge two Leftist Heaps",
      "struct LeftistNode *mergeLeftistHeaps(struct LeftistNode *heap1, struct LeftistNode *heap2)",
      "{",
      "// If one of the heaps is empty, return the other heap",
      "if (heap1 == NULL)",
      "{",
      "return heap2;",
      "}",
      "if (heap2 == NULL)",
      "{",
      "return heap1;",
      "}",
      "",
      "// heap1's root has a higher key",
      "if (heap1->key > heap2->key)",
      "{",
      "// Swap heap1 and heap2",
      "struct LeftistNode *temp = heap1;",
      "heap1 = heap2;",
      "heap2 = temp;",
      "}",
      "",
      "// Recursively merge the right subtree of heap1 with heap2",
      "heap1->right = mergeLeftistHeaps(heap1->right, heap2);",
      "",
      "// Update ranks to maintain leftist property",
      "if (heap1->left == NULL || (heap1->right != NULL && heap1->left->rank < heap1->right->rank))",
      "{",
      "// Swap the left and right children of heap1",
      "struct LeftistNode *temp = heap1->left;",
      "heap1->left = heap1->right;",
      "heap1->right = temp;",
      "}",
      "",
      "// Update the rank of heap1",
      "if (heap1->right == NULL)",
      "{",
      "heap1->rank = 0;",
      "}",
      "else",
      "{",
      "heap1->rank = heap1->right->rank + 1;",
      "}",
      "",
      "// Return the merged heap",
      "return heap1;",
      "}",
      "",
      "// Function to display the Leftist Heap",
      "void displayLeftistHeap(struct LeftistNode *root)",
      "{",
      "// If the heap is empty, return",
      "if (root == NULL)",
      "{",
      "return;",
      "}",
      "",
      "// Print the key of the root node",
      "printf(\"%d \", root->key);",
      "// Recursively display the left and right subtrees",
      "displayLeftistHeap(root->left);",
      "displayLeftistHeap(root->right);",
      "}",
      "",
      "// Example usage",
      "int main()",
      "{",
      "// Create two heaps",
      "struct LeftistNode *heap1 = createLeftistNode(3);",
      "heap1->left = createLeftistNode(10);",
      "heap1->right = createLeftistNode(8);",
      "",
      "struct LeftistNode *heap2 = createLeftistNode(6);",
      "heap2->left = createLeftistNode(7);",
      "heap2->right = createLeftistNode(5);",
      "",
      "// Display the heaps",
      "printf(\"Heap 1: \");",
      "displayLeftistHeap(heap1);",
      "printf(\"\\n\");",
      "",
      "printf(\"Heap 2: \");",
      "displayLeftistHeap(heap2);",
      "printf(\"\\n\");",
      "",
      "// Merge the heaps",
      "struct LeftistNode *mergedHeap = mergeLeftistHeaps(heap1, heap2);",
      "",
      "// Display the merged heap",
      "printf(\"Merged Heap: \");",
      "displayLeftistHeap(mergedHeap);",
      "printf(\"\\n\");",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "redBlackTree.c": {
    "prefix": "$redBlackTree",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "#define RED 0",
      "#define BLACK 1",
      "",
      "// Structure for a Red-Black Tree Node",
      "struct RBNode",
      "{",
      "int key;               // Node's key",
      "int color;             // Node's color (RED or BLACK)",
      "struct RBNode *parent; // Pointer to parent node",
      "struct RBNode *left;   // Pointer to left child",
      "struct RBNode *right;  // Pointer to right child",
      "};",
      "",
      "// Structure for a Red-Black Tree",
      "struct RBTree",
      "{",
      "struct RBNode *root; // Pointer to root of the tree",
      "};",
      "",
      "// Function to create a new node",
      "struct RBNode *createNode(int key)",
      "{",
      "struct RBNode *newNode = (struct RBNode *)malloc(sizeof(struct RBNode));",
      "if (newNode != NULL)",
      "{",
      "newNode->key = key;",
      "newNode->color = RED; // New nodes are always red",
      "newNode->parent = NULL;",
      "newNode->left = NULL;",
      "newNode->right = NULL;",
      "}",
      "return newNode;",
      "}",
      "",
      "// Function to perform left-rotation of tree",
      "void leftRotate(struct RBTree *tree, struct RBNode *x)",
      "{",
      "struct RBNode *y = x->right; // Set y",
      "x->right = y->left;          // Turn y's left subtree into x's right subtree",
      "",
      "if (y->left != NULL)",
      "{",
      "y->left->parent = x;",
      "}",
      "",
      "y->parent = x->parent; // Link x's parent to y",
      "",
      "if (x->parent == NULL)",
      "{",
      "tree->root = y; // If x has no parent, y becomes the root of the tree",
      "}",
      "else if (x == x->parent->left)",
      "{",
      "x->parent->left = y; // If x is a left child, set y to be left child of x's parent",
      "}",
      "else",
      "{",
      "x->parent->right = y; // If x is a right child, set y to be right child of x's parent",
      "}",
      "",
      "y->left = x; // Put x on y's left",
      "x->parent = y;",
      "}",
      "",
      "// Function to perform right-rotation of tree",
      "void rightRotate(struct RBTree *tree, struct RBNode *y)",
      "{",
      "struct RBNode *x = y->left; // Set x",
      "y->left = x->right;         // Turn x's right subtree into y's left subtree",
      "",
      "if (x->right != NULL)",
      "{",
      "x->right->parent = y;",
      "}",
      "",
      "x->parent = y->parent; // Link y's parent to x",
      "",
      "if (y->parent == NULL)",
      "{",
      "tree->root = x; // If y has no parent, x becomes the root of the tree",
      "}",
      "else if (y == y->parent->left)",
      "{",
      "y->parent->left = x; // If y is a left child, set x to be left child of y's parent",
      "}",
      "else",
      "{",
      "y->parent->right = x; // If y is a right child, set x to be right child of y's parent",
      "}",
      "",
      "x->right = y; // Put y on x's right",
      "y->parent = x;",
      "}",
      "",
      "// Function to fix the red-black tree after insertion of a node",
      "void fixInsert(struct RBTree *tree, struct RBNode *z)",
      "{",
      "// While z's parent is red",
      "while (z->parent != NULL && z->parent->color == RED)",
      "{",
      "// If z's parent is left child of its parent",
      "if (z->parent == z->parent->parent->left)",
      "{",
      "struct RBNode *y = z->parent->parent->right; // Uncle of z",
      "",
      "// Case 1: If uncle is red, only recoloring required",
      "if (y != NULL && y->color == RED)",
      "{",
      "z->parent->color = BLACK;",
      "y->color = BLACK;",
      "z->parent->parent->color = RED;",
      "z = z->parent->parent;",
      "}",
      "else",
      "{",
      "// Case 2: If z is right child, left rotation required",
      "if (z == z->parent->right)",
      "{",
      "z = z->parent;",
      "leftRotate(tree, z);",
      "}",
      "// Case 3: If z is left child, right rotation required",
      "z->parent->color = BLACK;",
      "z->parent->parent->color = RED;",
      "rightRotate(tree, z->parent->parent);",
      "}",
      "}",
      "else",
      "{",
      "// Similar logic to the above, but mirrored",
      "struct RBNode *y = z->parent->parent->left; // Uncle of z",
      "",
      "if (y != NULL && y->color == RED)",
      "{",
      "z->parent->color = BLACK;",
      "y->color = BLACK;",
      "z->parent->parent->color = RED;",
      "z = z->parent->parent;",
      "}",
      "else",
      "{",
      "if (z == z->parent->left)",
      "{",
      "z = z->parent;",
      "rightRotate(tree, z);",
      "}",
      "z->parent->color = BLACK;",
      "z->parent->parent->color = RED;",
      "leftRotate(tree, z->parent->parent);",
      "}",
      "}",
      "}",
      "tree->root->color = BLACK; // Root must always be black",
      "}",
      "",
      "// Function to insert a node to the tree",
      "void insert(struct RBTree *tree, int key)",
      "{",
      "struct RBNode *z = createNode(key); // Create a new node",
      "struct RBNode *y = NULL;",
      "struct RBNode *x = tree->root;",
      "",
      "// Traverse the tree down to a leaf",
      "while (x != NULL)",
      "{",
      "y = x;",
      "if (z->key < x->key)",
      "{",
      "x = x->left;",
      "}",
      "else",
      "{",
      "x = x->right;",
      "}",
      "}",
      "",
      "z->parent = y;",
      "",
      "// Decide whether to insert as left or right child",
      "if (y == NULL)",
      "{",
      "tree->root = z; // If tree was empty, z becomes root",
      "}",
      "else if (z->key < y->key)",
      "{",
      "y->left = z;",
      "}",
      "else",
      "{",
      "y->right = z;",
      "}",
      "",
      "// Fix the tree",
      "fixInsert(tree, z);",
      "}",
      "",
      "// Function for in-order tree traversal",
      "void inOrderTraversal(struct RBNode *root)",
      "{",
      "if (root != NULL)",
      "{",
      "inOrderTraversal(root->left);",
      "printf(\"%d \", root->key);",
      "inOrderTraversal(root->right);",
      "}",
      "}",
      "",
      "// Function to display the tree",
      "void displayRBTree(struct RBTree *tree)",
      "{",
      "if (tree->root != NULL)",
      "{",
      "inOrderTraversal(tree->root);",
      "printf(\"\\n\");",
      "}",
      "else",
      "{",
      "printf(\"Tree is empty.\\n\");",
      "}",
      "}",
      "",
      "// Main function",
      "int main()",
      "{",
      "struct RBTree *tree = (struct RBTree *)malloc(sizeof(struct RBTree));",
      "tree->root = NULL;",
      "",
      "int choice, key;",
      "",
      "do",
      "{",
      "printf(\"\\nMenu:\\n\");",
      "printf(\"1. Insert\\n\");",
      "printf(\"2. Display Red-Black Tree\\n\");",
      "printf(\"3. Exit\\n\");",
      "printf(\"Enter your choice: \");",
      "scanf(\"%d\", &choice);",
      "",
      "switch (choice)",
      "{",
      "case 1:",
      "printf(\"Enter the key to insert: \");",
      "scanf(\"%d\", &key);",
      "insert(tree, key);",
      "printf(\"Key %d inserted.\\n\", key);",
      "break;",
      "case 2:",
      "printf(\"Red-Black Tree: \");",
      "displayRBTree(tree);",
      "break;",
      "case 3:",
      "printf(\"Exiting...\\n\");",
      "break;",
      "default:",
      "printf(\"Invalid choice. Please try again.\\n\");",
      "}",
      "} while (choice != 3);",
      "",
      "free(tree);",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "btree.c": {
    "prefix": "$btree",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "",
      "#define M 3 // Order of the B-tree",
      "",
      "// Structure for BTree node",
      "struct BTreeNode",
      "{",
      "int leaf;                   // 1 if leaf, 0 if internal node",
      "int n;                      // Number of keys in the node",
      "int keys[M - 1];            // Array of keys",
      "struct BTreeNode *child[M]; // Array of child pointers",
      "};",
      "",
      "// Structure for BTree",
      "struct BTree",
      "{",
      "struct BTreeNode *root; // Pointer to root node",
      "};",
      "",
      "// Function to create a new B-tree node",
      "struct BTreeNode *createNode()",
      "{",
      "// Allocate memory for new node",
      "struct BTreeNode *newNode = (struct BTreeNode *)malloc(sizeof(struct BTreeNode));",
      "if (newNode != NULL)",
      "{",
      "newNode->leaf = 1; // Initialize as leaf",
      "newNode->n = 0;    // Initialize number of keys as 0",
      "for (int i = 0; i < M - 1; ++i)",
      "{",
      "newNode->keys[i] = 0;     // Initialize keys",
      "newNode->child[i] = NULL; // Initialize child pointers",
      "}",
      "newNode->child[M - 1] = NULL; // Initialize last child pointer",
      "}",
      "return newNode;",
      "}",
      "",
      "// Function to split a child node",
      "void splitChild(struct BTreeNode *x, int i)",
      "{",
      "// y is i-th child of x",
      "struct BTreeNode *y = x->child[i];",
      "// Allocate memory for new node z",
      "struct BTreeNode *z = createNode();",
      "",
      "// Update x's child pointers",
      "x->child[i] = y;",
      "x->child[i + 1] = z;",
      "",
      "// Copy y's properties to z",
      "z->leaf = y->leaf;",
      "z->n = (M - 1) / 2;",
      "",
      "// Copy y's keys to z",
      "for (int j = 0; j < z->n; ++j)",
      "{",
      "z->keys[j] = y->keys[j + (M + 1) / 2];",
      "}",
      "",
      "// If y is not a leaf, copy y's child pointers to z",
      "if (!y->leaf)",
      "{",
      "for (int j = 0; j <= z->n; ++j)",
      "{",
      "z->child[j] = y->child[j + (M + 1) / 2];",
      "}",
      "}",
      "",
      "// Update y's number of keys",
      "y->n = (M - 1) / 2;",
      "",
      "// Shift x's keys and child pointers to make room for new key and child",
      "for (int j = x->n; j > i; --j)",
      "{",
      "x->keys[j] = x->keys[j - 1];",
      "x->child[j + 1] = x->child[j];",
      "}",
      "",
      "// Copy middle key of y to x and update x's child pointer",
      "x->keys[i] = y->keys[(M - 1) / 2];",
      "x->child[i + 1] = z;",
      "x->n++; // Increment number of keys in x",
      "}",
      "",
      "// Function to insert a key into a B-tree",
      "void insertBTree(struct BTree *tree, int key)",
      "{",
      "struct BTreeNode *r = tree->root;",
      "if (r == NULL)",
      "{",
      "// If the tree is empty, create a new root",
      "tree->root = createNode();",
      "tree->root->keys[0] = key; // Insert key",
      "tree->root->n = 1;         // Update number of keys",
      "}",
      "else",
      "{",
      "if (r->n == M - 1)",
      "{",
      "// If the root is full, split it",
      "struct BTreeNode *s = createNode();",
      "tree->root = s;",
      "s->leaf = 0;           // s is an internal node",
      "s->child[0] = r;       // Make r child of s",
      "splitChild(s, 0);      // Split r and move one key to s",
      "insertNonFull(s, key); // Insert key into the B-tree rooted with s",
      "}",
      "else",
      "{",
      "// If the root is not full, call insertNonFull for r",
      "insertNonFull(r, key);",
      "}",
      "}",
      "}",
      "",
      "// Function to insert into a non-full B-tree node",
      "void insertNonFull(struct BTreeNode *x, int key)",
      "{",
      "int i = x->n - 1;",
      "if (x->leaf)",
      "{",
      "// If x is a leaf, insert the key into it",
      "while (i >= 0 && key < x->keys[i])",
      "{",
      "x->keys[i + 1] = x->keys[i]; // Shift keys",
      "i--;",
      "}",
      "x->keys[i + 1] = key; // Insert key",
      "x->n++;               // Increment number of keys",
      "}",
      "else",
      "{",
      "// If x is an internal node",
      "while (i >= 0 && key < x->keys[i])",
      "{",
      "i--; // Find location of new key",
      "}",
      "i++;",
      "if (x->child[i]->n == M - 1)",
      "{",
      "// If the found child is full, split it",
      "splitChild(x, i);",
      "if (key > x->keys[i])",
      "{",
      "i++; // After split, the key may go to the next child",
      "}",
      "}",
      "insertNonFull(x->child[i], key); // Insert key",
      "}",
      "}",
      "",
      "// Function to display the B-tree in-order",
      "void inOrderTraversal(struct BTreeNode *root)",
      "{",
      "if (root != NULL)",
      "{",
      "for (int i = 0; i < root->n; ++i)",
      "{",
      "inOrderTraversal(root->child[i]); // Recursive call for child",
      "printf(\"%d \", root->keys[i]);     // Print keys",
      "}",
      "inOrderTraversal(root->child[root->n]); // Recursive call for last child",
      "}",
      "}",
      "",
      "// Function to display the B-tree",
      "void displayBTree(struct BTree *tree)",
      "{",
      "if (tree->root != NULL)",
      "{",
      "inOrderTraversal(tree->root); // Call inOrderTraversal for root",
      "printf(\"\\n\");",
      "}",
      "else",
      "{",
      "printf(\"Tree is empty.\\n\");",
      "}",
      "}",
      "",
      "// Example usage",
      "int main()",
      "{",
      "struct BTree *tree = (struct BTree *)malloc(sizeof(struct BTree));",
      "tree->root = NULL;",
      "",
      "int choice, key;",
      "",
      "do",
      "{",
      "printf(\"\\nMenu:\\n\");",
      "printf(\"1. Insert\\n\");",
      "printf(\"2. Display B-tree\\n\");",
      "printf(\"3. Exit\\n\");",
      "printf(\"Enter your choice: \");",
      "scanf(\"%d\", &choice);",
      "",
      "switch (choice)",
      "{",
      "case 1:",
      "printf(\"Enter the key to insert: \");",
      "scanf(\"%d\", &key);",
      "insertBTree(tree, key); // Insert key",
      "printf(\"Key %d inserted.\\n\", key);",
      "break;",
      "case 2:",
      "printf(\"B-tree: \");",
      "displayBTree(tree); // Display B-tree",
      "break;",
      "case 3:",
      "printf(\"Exiting...\\n\");",
      "break;",
      "default:",
      "printf(\"Invalid choice. Please try again.\\n\");",
      "}",
      "} while (choice != 3);",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "intervalTree.c": {
    "prefix": "$intervalTree",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "// Structure to represent an interval",
      "struct Interval",
      "{",
      "int low;",
      "int high;",
      "};",
      "// Structure to represent a node in the interval tree",
      "struct IntervalNode",
      "{",
      "struct Interval *interval;",
      "int max; // Maximum endpoint in the subtree rooted at this node",
      "struct IntervalNode *left;",
      "struct IntervalNode *right;",
      "};",
      "// Function to create a new interval",
      "struct Interval *createInterval(int low, int high)",
      "{",
      "struct Interval *newInterval = (struct Interval *)malloc(sizeof(struct Interval));",
      "if (newInterval != NULL)",
      "{",
      "newInterval->low = low;",
      "newInterval->high = high;",
      "}",
      "return newInterval;",
      "}",
      "// Function to create a new interval tree node",
      "struct IntervalNode *createIntervalNode(struct Interval *interval)",
      "{",
      "struct IntervalNode *newNode = (struct IntervalNode *)malloc(sizeof(struct IntervalNode));",
      "if (newNode != NULL)",
      "{",
      "newNode->interval = interval;",
      "newNode->max = interval->high;",
      "newNode->left = NULL;",
      "newNode->right = NULL;",
      "}",
      "return newNode;",
      "}",
      "// Function to insert an interval into the interval tree",
      "struct IntervalNode *insertInterval(struct IntervalNode *root, struct Interval *interval)",
      "{",
      "if (root == NULL)",
      "{",
      "return createIntervalNode(interval);",
      "}",
      "// Get the low endpoint of the interval at the root",
      "int low = root->interval->low;",
      "",
      "if (interval->low < low)",
      "{   // Insert into the left subtree",
      "root->left = insertInterval(root->left, interval);",
      "}",
      "else",
      "{   // Insert into the right subtree",
      "root->right = insertInterval(root->right, interval);",
      "}",
      "",
      "if (root->max < interval->high)",
      "{",
      "root->max = interval->high;",
      "}",
      "",
      "return root;",
      "}",
      "// Function to check if two intervals overlap",
      "int doOverlap(struct Interval *a, struct Interval *b)",
      "{",
      "return (a->low <= b->high && b->low <= a->high);",
      "}",
      "// Function to search for overlapping intervals in the interval tree",
      "void searchOverlap(struct IntervalNode *root, struct Interval *interval)",
      "{",
      "if (root == NULL)",
      "{",
      "return;",
      "}",
      "",
      "if (doOverlap(root->interval, interval))",
      "{",
      "printf(\"Overlap found: [%d, %d] overlaps with [%d, %d]\\n\",",
      "root->interval->low, root->interval->high,",
      "interval->low, interval->high);",
      "}",
      "",
      "// Check if the left subtree needs to be searched",
      "if (root->left != NULL && root->left->max >= interval->low)",
      "{",
      "searchOverlap(root->left, interval);",
      "}",
      "",
      "// Check if the right subtree needs to be searched",
      "if (root->right != NULL && root->right->max >= interval->low)",
      "{",
      "searchOverlap(root->right, interval);",
      "}",
      "}",
      "// Function to display in-order traversal of the interval tree",
      "void inOrderTraversal(struct IntervalNode *root)",
      "{",
      "if (root != NULL)",
      "{",
      "inOrderTraversal(root->left);",
      "printf(\"[%d, %d] \", root->interval->low, root->interval->high);",
      "inOrderTraversal(root->right);",
      "}",
      "}",
      "// Function to free memory allocated for the interval tree",
      "void freeIntervalTree(struct IntervalNode *root)",
      "{",
      "if (root != NULL)",
      "{",
      "freeIntervalTree(root->left);",
      "freeIntervalTree(root->right);",
      "free(root->interval);",
      "free(root);",
      "}",
      "}",
      "int main()",
      "{",
      "struct IntervalNode *root = NULL;",
      "int choice;",
      "",
      "do",
      "{",
      "printf(\"\\n1. Insert Interval\");",
      "printf(\"\\n2. Search Overlapping Intervals\");",
      "printf(\"\\n3. Display In-order Traversal\");",
      "printf(\"\\n4. Exit\");",
      "printf(\"\\nEnter your choice: \");",
      "scanf(\"%d\", &choice);",
      "",
      "switch (choice)",
      "{",
      "case 1:",
      "{",
      "int low, high;",
      "printf(\"Enter interval low: \");",
      "scanf(\"%d\", &low);",
      "printf(\"Enter interval high: \");",
      "scanf(\"%d\", &high);",
      "struct Interval *newInterval = createInterval(low, high);",
      "root = insertInterval(root, newInterval);",
      "printf(\"Interval inserted successfully.\\n\");",
      "break;",
      "}",
      "case 2:",
      "{",
      "int searchLow, searchHigh;",
      "printf(\"Enter search interval low: \");",
      "scanf(\"%d\", &searchLow);",
      "printf(\"Enter search interval high: \");",
      "scanf(\"%d\", &searchHigh);",
      "struct Interval searchInterval = {searchLow, searchHigh};",
      "// printf(\"Searching for overlaps with [%d, %d]\\n\", searchInterval.low, searchInterval.high);",
      "searchOverlap(root, &searchInterval);",
      "break;",
      "}",
      "case 3:",
      "{",
      "printf(\"Interval Tree (In-order traversal): \");",
      "inOrderTraversal(root);",
      "printf(\"\\n\");",
      "break;",
      "}",
      "case 4:",
      "{   // Free memory",
      "freeIntervalTree(root);",
      "printf(\"Exiting...\\n\");",
      "break;",
      "}",
      "default:",
      "{",
      "printf(\"Invalid choice. Please enter a valid option.\\n\");",
      "break;",
      "}",
      "}",
      "} while (choice != 4);",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "segmentTree.c": {
    "prefix": "$segmentTree",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#define MAX_N 8 // Maximum number of elements in the input array",
      "// Structure to represent a node in the Segment Tree",
      "struct SegmentTreeNode",
      "{",
      "int sum; // Sum of the elements in the interval represented by this node",
      "int min; // Minimum element in the interval represented by this node",
      "int max; // Maximum element in the interval represented by this node",
      "};",
      "// Function to build the Segment Tree from an input array",
      "void buildSegmentTree(int arr[], struct SegmentTreeNode *tree, int start, int end, int index)",
      "{",
      "// If the start and end of the interval are the same (i.e., the interval has only one element),",
      "// then the sum, minimum, and maximum are just the element itself",
      "if (start == end)",
      "{",
      "tree[index].sum = arr[start];",
      "tree[index].min = arr[start];",
      "tree[index].max = arr[start];",
      "return;",
      "}",
      "",
      "// Calculate the mid-point of the interval",
      "int mid = (start + end) / 2;",
      "// Calculate the indices of the left and right children of the current node",
      "int leftIndex = 2 * index + 1;",
      "int rightIndex = 2 * index + 2;",
      "",
      "// Recursively build the left and right subtrees",
      "buildSegmentTree(arr, tree, start, mid, leftIndex);",
      "buildSegmentTree(arr, tree, mid + 1, end, rightIndex);",
      "",
      "// The sum, minimum, and maximum of the current node are calculated from its left and right children",
      "tree[index].sum = tree[leftIndex].sum + tree[rightIndex].sum;",
      "tree[index].min = (tree[leftIndex].min < tree[rightIndex].min) ? tree[leftIndex].min : tree[rightIndex].min;",
      "tree[index].max = (tree[leftIndex].max > tree[rightIndex].max) ? tree[leftIndex].max : tree[rightIndex].max;",
      "}",
      "// Function to query the Segment Tree for the sum, minimum, or maximum of a given interval",
      "void querySegmentTree(struct SegmentTreeNode *tree, int start, int end, int qstart, int qend, int index, int operation)",
      "{",
      "// If the query interval does not overlap with the interval represented by the current node, return",
      "if (qstart > end || qend < start)",
      "{",
      "return;",
      "}",
      "// If the query interval completely overlaps with the interval represented by the current node,",
      "// print the sum, minimum, or maximum as per the operation",
      "if (qstart <= start && qend >= end)",
      "{",
      "if (operation == 1)",
      "{",
      "// Sum",
      "printf(\"Sum of interval [%d, %d]: %d\\n\", start, end, tree[index].sum);",
      "}",
      "else if (operation == 2)",
      "{",
      "// Minimum",
      "printf(\"Minimum of interval [%d, %d]: %d\\n\", start, end, tree[index].min);",
      "}",
      "else if (operation == 3)",
      "{",
      "// Maximum",
      "printf(\"Maximum of interval [%d, %d]: %d\\n\", start, end, tree[index].max);",
      "}",
      "return;",
      "}",
      "",
      "// If the query interval partially overlaps with the interval represented by the current node,",
      "// recursively query both the left and right children",
      "int mid = (start + end) / 2;",
      "int leftIndex = 2 * index + 1;",
      "int rightIndex = 2 * index + 2;",
      "",
      "querySegmentTree(tree, start, mid, qstart, qend, leftIndex, operation);",
      "querySegmentTree(tree, mid + 1, end, qstart, qend, rightIndex, operation);",
      "}",
      "",
      "// Function to display the elements of the Segment Tree",
      "void displaySegmentTree(struct SegmentTreeNode *tree, int n)",
      "{",
      "printf(\"Segment Tree:\\n\");",
      "// Loop through the Segment Tree and print the sum, minimum, and maximum of each node",
      "for (int i = 0; i < n; ++i)",
      "{",
      "printf(\"Index %d: Sum=%d, Min=%d, Max=%d\\n\", i, tree[i].sum, tree[i].min, tree[i].max);",
      "}",
      "printf(\"\\n\");",
      "}",
      "",
      "int main()",
      "{",
      "// Hardcoded input array",
      "int inputArray[] = {1, 3, 5, 7, 9, 11, 13, 15};",
      "// Calculate the height of the Segment Tree",
      "int height = 3;",
      "// Keep doubling the height until it is large enough to accommodate all elements of the input array",
      "// while ((1 << height) < MAX_N)",
      "// {",
      "//     height++;",
      "// }",
      "// printf(\"Calculated height of the Segment Tree: %d\\n\", height); // Print the calculated height",
      "// Calculate the total number of nodes in the Segment Tree",
      "int treeSize = 15;",
      "// printf(\"Calculated size of the Segment Tree: %d\\n\", treeSize); // Print the calculated tree size",
      "",
      "// Create and initialize the Segment Tree",
      "struct SegmentTreeNode *segmentTree = (struct SegmentTreeNode *)malloc(treeSize * sizeof(struct SegmentTreeNode));",
      "// Build the Segment Tree from the input array",
      "buildSegmentTree(inputArray, segmentTree, 0, MAX_N - 1, 0);",
      "int choice, qstart, qend;",
      "do",
      "{",
      "// Display the menu and get the user's choice",
      "printf(\"Menu:\\n\");",
      "printf(\"1. Find Sum of Interval\\n\");",
      "printf(\"2. Find Minimum of Interval\\n\");",
      "printf(\"3. Find Maximum of Interval\\n\");",
      "printf(\"4. Display Segment Tree\\n\");",
      "printf(\"5. Exit\\n\");",
      "printf(\"Enter your choice: \");",
      "scanf(\"%d\", &choice);",
      "switch (choice)",
      "{",
      "case 1:",
      "case 2:",
      "case 3:",
      "// If the user wants to find the sum, minimum, or maximum of an interval,",
      "// get the interval from the user and query the Segment Tree",
      "printf(\"Enter interval [start end]: \");",
      "scanf(\"%d %d\", &qstart, &qend);",
      "querySegmentTree(segmentTree, 0, MAX_N - 1, qstart, qend, 0, choice);",
      "break;",
      "case 4:",
      "// If the user wants to display the Segment Tree, call the display function",
      "displaySegmentTree(segmentTree, treeSize);",
      "break;",
      "case 5:",
      "// If the user wants to exit, print a message and break from the loop",
      "printf(\"Exiting...\\n\");",
      "break;",
      "default:",
      "// If the user enters an invalid choice, print an error message",
      "printf(\"Invalid choice. Please try again.\\n\");",
      "}",
      "} while (choice != 5);",
      "",
      "// Free the memory allocated for the Segment Tree",
      "free(segmentTree);",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "bloomFilter.c": {
    "prefix": "$bloomFilter",
    "body": [
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#define SIZE 10",
      "// Bloom Filter sketch",
      "bool sketch[SIZE];",
      "// Hash function 1",
      "unsigned int hash1(char* value) {",
      "unsigned int hash = 0;",
      "for (int i = 0; value[i] != '\\0'; i++) {",
      "hash = hash + value[i];",
      "}",
      "return hash % SIZE;",
      "}",
      "// Hash function 2",
      "unsigned int hash2(char* value) {",
      "unsigned int hash = 0;",
      "for (int i = 0; value[i] != '\\0'; i++) {",
      "hash = hash * 31 + value[i];",
      "}",
      "return hash % SIZE;",
      "}",
      "// Hash function 3",
      "unsigned int hash3(char* value) {",
      "unsigned int hash = 5381;",
      "for (int i = 0; value[i] != '\\0'; i++) {",
      "hash = ((hash << 5) + hash) + value[i];",
      "}",
      "return hash % SIZE;",
      "}",
      "// Insert an element into the Bloom Filter",
      "void insert(char* value) {",
      "sketch[hash1(value)] = true;",
      "sketch[hash2(value)] = true;",
      "sketch[hash3(value)] = true;",
      "}",
      "// Check if an element is present in the Bloom Filter",
      "bool contains(char* value) {",
      "return sketch[hash1(value)] && sketch[hash2(value)] && sketch[hash3(value)];",
      "}",
      "int main() {",
      "insert(\"apple\");",
      "insert(\"apple\");",
      "insert(\"cherry\");",
      "",
      "printf(\"Contains apple: %d\\n\", contains(\"apple\"));",
      "printf(\"Contains banana: %d\\n\", contains(\"banana\"));",
      "printf(\"Contains cherry: %d\\n\", contains(\"cherry\"));",
      "printf(\"Contains mango: %d\\n\", contains(\"mango\"));",
      "for(int i = 0; i < SIZE; i++) {",
      "printf(\"%d \", sketch[i]);",
      "}",
      "",
      "return 0;",
      "}"
    ],
    "description": "Your description here"
  },
  "cuckooHashing.c": {
    "prefix": "$cuckooHashing",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#define MAXN 11 // Maximum number of keys in the hash table",
      "// Arrays to store the hash tables",
      "int hashtable1[MAXN];",
      "int hashtable2[MAXN];",
      "// Function to create a hash function",
      "int hashfunction(int function, int key)",
      "{",
      "switch (function)",
      "{",
      "case 1:",
      "return key % MAXN;",
      "case 2:",
      "return (key / MAXN) % MAXN;",
      "}",
      "return 0;",
      "}",
      "// Function to place a key in the cuckoo hash table",
      "void place(int key, int tableNumber)",
      "{",
      "int pos, i, temp;",
      "for (i = 0; i < MAXN; i++)",
      "{",
      "if (tableNumber == 1)",
      "{",
      "pos = hashfunction(1, key);",
      "if (hashtable1[pos] == -1)",
      "{",
      "hashtable1[pos] = key;",
      "return;",
      "}",
      "temp = hashtable1[pos];",
      "hashtable1[pos] = key;",
      "key = temp;",
      "tableNumber = 2;",
      "}",
      "else",
      "{",
      "pos = hashfunction(2, key);",
      "if (hashtable2[pos] == -1)",
      "{",
      "hashtable2[pos] = key;",
      "return;",
      "}",
      "temp = hashtable2[pos];",
      "hashtable2[pos] = key;",
      "key = temp;",
      "tableNumber = 1;",
      "}",
      "}",
      "}",
      "// Function to insert a key into the hash table",
      "void insert(int key)",
      "{",
      "int pos = hashfunction(1, key);",
      "if (hashtable1[pos] != -1)",
      "{",
      "int temp = hashtable1[pos];",
      "hashtable1[pos] = key;",
      "place(temp, 2);",
      "}",
      "else",
      "{",
      "hashtable1[pos] = key;",
      "}",
      "}",
      "",
      "int main()",
      "{",
      "int i;",
      "for (i = 0; i < MAXN; i++)",
      "{",
      "hashtable1[i] = -1;",
      "hashtable2[i] = -1;",
      "}",
      "",
      "insert(20);",
      "insert(50);",
      "insert(53);",
      "insert(75);",
      "insert(100);",
      "insert(67);",
      "insert(105);",
      "insert(3);",
      "insert(36);",
      "insert(39);",
      "",
      "printf(\"The hash table 1 is:\\n\");",
      "for (i = 0; i < MAXN; i++)",
      "{",
      "printf(\"%d \", hashtable1[i]);",
      "}",
      "",
      "printf(\"\\nThe hash table 2 is:\\n\");",
      "for (i = 0; i < MAXN; i++)",
      "{",
      "printf(\"%d \", hashtable2[i]);",
      "}",
      "",
      "return 0;",
      "}",
      "",
      "// hashtable1 and hashtable2 are the two hash tables.",
      "// The insert function first tries to insert the key into hashtable1.",
      "//If there's a collision, it replaces the key at the colliding position and tries to place the replaced key into hashtable2 using the place function.",
      "// The place function alternates between the two tables until it finds an empty position or it has iterated MAXN times."
    ],
    "description": "Your description here"
  },
  "perfectHashing.c": {
    "prefix": "$perfectHashing",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "// Define the secondary table structure",
      "struct SecondaryTable",
      "{",
      "int *table; // Pointer to the array that will hold the keys",
      "int size;   // Size of the secondary table",
      "} ;",
      "// Define the perfect hash table structure",
      "struct PerfectHashTable",
      "{",
      "struct SecondaryTable *secondaryTables; // Array of secondary tables",
      "int size;                        // Size of the primary table",
      "} ;",
      "",
      "// Primary hash function",
      "int primaryHashFunction(int key, int size)",
      "{",
      "return key % size; // Simple modulus hash function",
      "}",
      "// Secondary hash function",
      "int secondaryHashFunction(int key, int size)",
      "{",
      "int prime = 101;                       // Prime number",
      "int a = 3;                             // Coefficient a for the hash function",
      "int b = 42;                            // Coefficient b for the hash function",
      "return ((a * key + b) % prime) % size; // Hash function formula",
      "}",
      "// Function to create a new perfect hash table",
      "struct PerfectHashTable *createPerfectHashTable(int size)",
      "{",
      "struct PerfectHashTable *newTable = malloc(sizeof(struct PerfectHashTable));     // Allocate memory for the perfect hash table",
      "newTable->secondaryTables = malloc(sizeof(struct SecondaryTable) * size);         // Allocate memory for the array of secondary tables",
      "newTable->size = size;                                             // Set the size of the primary table",
      "for (int i = 0; i < size; i++)",
      "{",
      "newTable->secondaryTables[i].table = NULL; // Initialize each secondary table to NULL",
      "newTable->secondaryTables[i].size = 0;     // Initialize the size of each secondary table to 0",
      "}",
      "return newTable; // Return the new perfect hash table",
      "}",
      "// Function to insert a key into the perfect hash table",
      "void insert(struct PerfectHashTable *perfectTable, int key)",
      "{",
      "int primaryIndex = primaryHashFunction(key, perfectTable->size);               // Calculate the primary index",
      "struct SecondaryTable *secondaryTable = &perfectTable->secondaryTables[primaryIndex]; // Get the secondary table at the primary index",
      "if (secondaryTable->table == NULL)                                             // If the secondary table is NULL",
      "{",
      "secondaryTable->table = malloc(sizeof(int) * perfectTable->size); // Allocate memory for the secondary table",
      "for (int i = 0; i < perfectTable->size; i++)                      // Initialize all elements to -1",
      "{",
      "secondaryTable->table[i] = -1;",
      "}",
      "secondaryTable->size = perfectTable->size; // Set the size of the secondary table",
      "}",
      "// Calculate the secondary index",
      "int secondaryIndex = secondaryHashFunction(key, secondaryTable->size);",
      "// Insert the key at the secondary index",
      "secondaryTable->table[secondaryIndex] = key;",
      "}",
      "// Function to print the perfect hash table",
      "void printPerfectHashTable(struct PerfectHashTable *perfectTable)",
      "{",
      "for (int i = 0; i < perfectTable->size; i++) // For each primary index",
      "{",
      "struct SecondaryTable *secondaryTable = &perfectTable->secondaryTables[i]; // Get the secondary table at the primary index",
      "printf(\"Primary index %d:\\n\", i);",
      "for (int j = 0; j < secondaryTable->size; j++)                      // For each secondary index",
      "{",
      "printf(\"  Secondary index %d: %d\\n\", j, secondaryTable->table[j]); // Print the secondary index and the key at that index",
      "}",
      "}",
      "}",
      "int main()",
      "{",
      "struct PerfectHashTable *perfectTable = createPerfectHashTable(9);",
      "insert(perfectTable, 75);",
      "insert(perfectTable, 15);",
      "insert(perfectTable, 32);",
      "printPerfectHashTable(perfectTable);",
      "return 0;",
      "}",
      ""
    ],
    "description": "Your description here"
  }
}
